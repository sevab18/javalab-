lab 1 Java OOP Practice - –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–∞–≥–∞–∑–∏–Ω–æ–º üõí
–û–ø–∏—Å–∞–Ω–∏–µ üìã –∑–∞–¥–∞—á–∏
–°–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ—Å—Ç—É—é —Å–∏—Å—Ç–µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–∞–≥–∞–∑–∏–Ω–æ–º, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ Java. –°–∏—Å—Ç–µ–º–∞ –¥–æ–ª–∂–Ω–∞ –≤–∫–ª—é—á–∞—Ç—å –∫–ª–∞—Å—Å—ã Product –∏ Category, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞—é—Ç –≤–º–µ—Å—Ç–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–ø–∞—Å–∞–º–∏. üè∑Ô∏è

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ üóÇÔ∏è –ø—Ä–æ–µ–∫—Ç–∞
src/ ‚îú‚îÄ‚îÄ product/ ‚îÇ ‚îú‚îÄ‚îÄ Product.java # –ö–ª–∞—Å—Å —Ç–æ–≤–∞—Ä–∞ —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º üè™ –∑–∞–ø–∞—Å–∞–º–∏ ‚îÇ ‚îî‚îÄ‚îÄ ShopDemo.java # –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ üéâ –ø—Ä–æ–¥—É–∫—Ç–∞ ‚îî‚îÄ‚îÄ –∫–∞—Ç–µ–≥–æ—Ä–∏—è/ ‚îî‚îÄ‚îÄ Category.java # –ö–ª–∞—Å—Å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤ üì¶

–û–±–∑–æ—Ä üìö –∫–ª–∞—Å—Å–æ–≤
–ö–ª–∞—Å—Å –ø—Ä–æ–¥—É–∫—Ç–∞ (product. –ü—Ä–æ–¥—É–∫—Ç) üè∑Ô∏è
–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: –ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã –≤ –º–∞–≥–∞–∑–∏–Ω–µ üõçÔ∏è

–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:

–ê—Ç—Ä–∏–±—É—Ç—ã —Ç–æ–≤–∞—Ä–∞: ID, –Ω–∞–∑–≤–∞–Ω–∏–µ, –æ–ø–∏—Å–∞–Ω–∏–µ, —Ü–µ–Ω–∞, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –∫–∞—Ç–µ–≥–æ—Ä–∏—è, —Å–æ—Å—Ç–æ—è–Ω–∏–µ üí∞ –Ω–∞ —Å–∫–ª–∞–¥–µ
–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã: –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ üõ†Ô∏è
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∞—Å–∞–º–∏: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Å—Ç–∞—Ç–∫–æ–≤, –ø—Ä–æ–¥–∞–∂–∞ —Ç–æ–≤–∞—Ä–æ–≤ üìà
–ë–∏–∑–Ω–µ—Å-–æ–ø–µ—Ä–∞—Ü–∏–∏: –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–∫–∏–¥–æ–∫, —Ä–∞—Å—á–µ—Ç –æ–±—â–µ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏ üíµ
–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ü–µ–Ω–µ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É ‚úÖ
–û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã:

addStock(int amount) - –î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∞—Å—ã ‚ûï
sellProduct(int amount) - –ü—Ä–æ–¥–∞–≤–∞—Ç—å —Ç–æ–≤–∞—Ä—ã —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π üõí
applyDiscount(double percent) - –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç–Ω—É—é —Å–∫–∏–¥–∫—É üí∏
calculateTotalValue() - –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å üìä –∑–∞–ø–∞—Å–æ–≤
displayProductInfo() - –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–¥—É–∫—Ç–µ üìñ
–ö–∞—Ç–µ–≥–æ—Ä–∏—è –ö–ª–∞—Å—Å (–∫–∞—Ç–µ–≥–æ—Ä–∏—è. –ö–∞—Ç–µ–≥–æ—Ä–∏—è) üì¶
–¶–µ–ª—å: –£–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º üìÇ

–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:

–ê—Ç—Ä–∏–±—É—Ç—ã –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: ID, –∏–º—è, –æ–ø–∏—Å–∞–Ω–∏–µ üè∑Ô∏è
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ üì¶ –∫–æ–ª–ª–µ–∫—Ü–∏–µ–π —Ç–æ–≤–∞—Ä–æ–≤
–†–∞—Å—á–µ—Ç—ã üìä –Ω–∞ —É—Ä–æ–≤–Ω–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
–û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã:

addProduct(–ü—Ä–æ–¥—É–∫—Ç –ø—Ä–æ–¥—É–∫—Ç–∞) - –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏—é ‚ûï
removeProduct(–ü—Ä–æ–¥—É–∫—Ç –ø—Ä–æ–¥—É–∫—Ç–∞) - –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚ûñ
getTotalValue() - –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ–±—â—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ üí∞
displayCategoryInfo() - –ü–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏ –µ–µ –ø—Ä–æ–¥—É–∫—Ç—ã üìã

lab 2
Practice 2 ‚Äî Encapsulation & Validation Guard (Tech Requirement)

Theme: Keep your objects in a valid state. Builds on: Task 1 (Product, Category, ShopDemo). Rule of thumb: No invalid data gets inside Product.

---

üéØ Goal

Refactor product.Product (and a tiny bit of category.Category) to enforce encapsulation and add simple validation guards. No exceptions yet, no complex patterns. Just private fields + guarded updates that return boolean.

---

‚úÖ What to change (minimal & easy)

1) Encapsulation

¬∑ All fields in Product must be private.

¬∑ Expose state via getters only.

¬∑ Replace plain setters with guarded mutators that return boolean and do nothing on invalid input.

2) Validation rules (keep it simple)

¬∑ id: not null, trimmed length >= 2.

¬∑ name: not null, trimmed length >= 2.

¬∑ description: can be null or trimmed; if not null, length <= 200.

¬∑ price: >= 0.0 and <= 1_000_000.0.

¬∑ quantity: >= 0 and <= 1_000_000.

¬∑ category: not null.

¬∑ Discounts: percent must be 0..90. If outside ‚Üí ignore and return original price in preview.

3) Guarded mutators (proposed signatures)

// inside product.Product

public boolean trySetId(String id);

public boolean trySetName(String name);

public boolean trySetDescription(String description);

public boolean trySetPrice(double price);

public boolean trySetQuantity(int quantity);

public boolean trySetCategory(category.Category category);

¬∑ Return true only if the field is updated.

¬∑ On invalid input: return false and do not change the field.

4) Use guards in inventory methods

¬∑ addStock(int amount): accept only amount > 0; update quantity; return true/false.

¬∑ sellProduct(int amount): only if amount > 0 and amount <= quantity; update quantity; return true/false.

¬∑ applyDiscount(double percent): if percent not in 0..90, do nothing and return false; if valid, apply new price and return true.

o (If your Task 1 had a ‚Äúpreview‚Äù method instead of mutation, keep that; just enforce the 0..90 rule.)

¬∑ calculateTotalValue(): unchanged (but now it relies on guarded values).

5) Computed stock status (no direct setter)

¬∑ Remove any public setter for ‚Äústock status‚Äù.

¬∑ Provide a derived read-only method:

public String getStockStatus(); // returns "OUT_OF_STOCK" (0), "LOW" (1..10), or "IN_STOCK" (>10)

¬∑ Thresholds: 0 ‚Üí OUT_OF_STOCK, 1..10 ‚Üí LOW, >10 ‚Üí IN_STOCK.

6) Category safety (tiny change)

¬∑ In category.Category, make addProduct(Product p) return boolean:

o Reject null.

o Reject duplicates of the same object reference (simple contains check).

¬∑ removeProduct(Product p) can stay as in Task 1 (or return boolean if you prefer).

---

üß™ Demo requirements (product.ShopDemo)

Update your demo to prove guards work:

1. Create a Category (e.g., ‚ÄúStationery‚Äù) and a Product (e.g., Pen).

2. Accepted updates:

o trySetPrice(250.0) ‚Üí true

o addStock(20) when quantity was, say, 5 ‚Üí true ‚Üí quantity becomes 25

3. Rejected updates:

o trySetPrice(-1.0) ‚Üí false (price unchanged)

o trySetName("A") ‚Üí false (name unchanged)

o sellProduct(10_000) if quantity is lower ‚Üí false (quantity unchanged)

o applyDiscount(200) ‚Üí false (ignored)

4. Show getStockStatus() before/after restocks/sales.

5. Add the product to the category twice; the second add must be rejected.

Print each action and the resulting state so it‚Äôs obvious what passed/failed.

---

‚úÖ Acceptance Criteria

¬∑ All Product fields are private; external code cannot mutate them directly.

¬∑ Guarded mutators above exist and preserve old values on invalid input.

¬∑ Inventory methods (addStock, sellProduct, applyDiscount) validate inputs and return boolean.

¬∑ getStockStatus() is computed from quantity (no direct setter).

¬∑ Category.addProduct rejects null and duplicates (by reference).

¬∑ ShopDemo prints at least 2 accepted and 3 rejected actions.

---

üìä Suggested Grading ( /10 )

¬∑ Encapsulation (private fields + getters) ‚Äî 2

¬∑ Guarded mutators work (return boolean, no state corruption) ‚Äî 4

¬∑ Inventory methods validate correctly ‚Äî 2

¬∑ Demo proves both accepted/rejected flows + stock status ‚Äî 2

lab 3
Practice 3 ‚Äî Constructors & Static Factory (Tech Requirement)

Builds on: Task 1 (basic Product) & Task 2 (encapsulation + guards). Theme: Learn constructor overloading, constructor chaining, default initialization, and simple static members / static factory methods.


Goal

Enhance product.Product to support multiple constructors and static factory helpers, while keeping validation simple and consistent with Task 2.


What to add (easy & minimal)

A) Constructors (overloaded + chained)

Implement three constructors for Product:

1. No-args constructor ‚Äî sets safe defaults:

o id = "AUTO-" + nextSeq()

o name = "Unnamed"

o description = null

o price = 0.0

o quantity = 0

o category = null (can be set later)

2. Required-args constructor ‚Äî id, name, price:

public Product(String id, String name, double price)

o Sets quantity = 0, description = null, category = null.

3. Full-args constructor ‚Äî id, name, description, price, quantity, category.

Rules:

¬∑ Use constructor chaining with this(...) to avoid code duplication.

¬∑ Inside constructors, reuse your guards from Task 2: call trySetX methods. If a guard returns false, keep the current value (default from the chained constructor).

B) Static members

Add these static members to Product:

¬∑ public static final String DEFAULT_CURRENCY = "KZT";

¬∑ private static int SEQ = 1; ‚Äî simple product id sequence.

¬∑ public static int getCreatedCount() ‚Äî how many Product objects were created (increment in each constructor).

Helper:

private static String nextSeq() { return String.valueOf(SEQ++); }

C) Static factory methods (friendly names)

Add two static factory methods:

1. public static Product of(String id, String name, double price)

o Equivalent to the required-args constructor.

2. public static Product freeSample(String name)

o Creates a product with:

¬ß auto id (AUTO-...),

¬ß given name,

¬ß price = 0.0,

¬ß quantity = 1.

Tip: Static factories can have good names and can return preconfigured instances.


Demo (product.ShopDemo or product.ShopDemo3)

Print results to show all flows:

1. Create products via each constructor + the two static factories.

2. Show automatically assigned ids (AUTO-1, AUTO-2, ...).

3. Prove guards still work when constructor parameters are invalid (e.g., new Product("", "A", -5) should keep safe defaults for those fields).

4. Print Product.getCreatedCount() at the end.

Example usage (you can copy into your demo):

Product p1 = new Product(); // no-args

Product p2 = new Product("P100", "Notebook", 950.0); // required-args

Product p3 = new Product("P200", "Headphones", "BT 5.0", 14990.0, 5, electronics); // full-args


Product p4 = Product.of("P300", "Pencil", 120.0); // static factory

Product p5 = Product.freeSample("Sticker"); // static factory


System.out.println(p1);

System.out.println(p2);

System.out.println(p3);

System.out.println(p4);

System.out.println(p5);


System.out.println("Created count = " + Product.getCreatedCount());

lab 4
Practice 4 ‚Äî Why Product Subtypes Beat Other Inheritance Options

Builds on: Task 1‚Äì3 (Product with encapsulation, constructors, static factory). Scope: Analysis of inheritance design choices in e-commerce systems.

---

üéØ Objective

Analyze why Product subtypes (Physical/Digital) is the best inheritance choice compared to other common e-commerce hierarchies:

1. ShippingOption hierarchy ‚Äî needs logistics context

2. PaymentMethod hierarchy ‚Äî needs Orders/Checkout system

3. Review hierarchy ‚Äî isn't great for inheritance

4. Product subtypes ‚Äî you already implemented (Physical/Digital) ‚úÖ

---

üîç Analysis: Why Product Subtypes Win

‚ùå Why Other Options Don't Work Well

1. ShippingOption Hierarchy

// PROBLEMATIC: Too much logistics context needed

abstract class ShippingOption {

abstract double calculateCost(Address from, Address to, Package package);

abstract int estimateDays(Address from, Address to);

abstract boolean isAvailable(Address from, Address to);

}

class StandardShipping extends ShippingOption { ... }

class ExpressShipping extends ShippingOption { ... }

class OvernightShipping extends ShippingOption { ... }

Issues:

¬∑ Requires complex logistics system (Address, Package, routing)

¬∑ Needs external APIs for real-time shipping rates

¬∑ Too much business logic outside core product domain

¬∑ Hard to test without full shipping infrastructure

2. PaymentMethod Hierarchy

// PROBLEMATIC: Needs complete checkout system

abstract class PaymentMethod {

abstract boolean processPayment(double amount, String currency);

abstract String getTransactionId();

abstract boolean refund(String transactionId, double amount);

}

class CreditCard extends PaymentMethod { ... }

class PayPal extends PaymentMethod { ... }

class BankTransfer extends PaymentMethod { ... }

Issues:

¬∑ Requires Orders, Checkout, Transaction entities

¬∑ Needs payment gateway integrations

¬∑ Security concerns (PCI compliance)

¬∑ Complex state management across payment flow

3. Review Hierarchy

// PROBLEMATIC: Not good inheritance candidate

abstract class Review {

String content;

int rating;

Date createdAt;

}

class ProductReview extends Review { ... }

class SellerReview extends Review { ... }

class ServiceReview extends Review { ... }

Issues:

¬∑ Very similar behavior across subclasses

¬∑ Better suited for composition (Review + Reviewable interface)

¬∑ Rating logic is identical across types

¬∑ Content validation is the same

‚úÖ Why Product Subtypes Are Perfect

4. Product Subtypes (Physical/Digital) - IMPLEMENTED ‚úÖ

// EXCELLENT: Clear domain boundaries, distinct behaviors

public class PhysicalProduct extends Product {

private double weightKg;

private double lengthCm, widthCm, heightCm;


public double estimateShippingCost() {

// Physical-specific: volumetric calculation

double volumetric = (lengthCm * widthCm * heightCm) / 5000.0;

return Math.max(weightKg, volumetric) * 100;

}

}


public class DigitalProduct extends Product {

private double downloadSizeMb;

private String licenseKey;


public boolean isLicenseRequired() {

// Digital-specific: license validation

return licenseKey != null && !licenseKey.isBlank();

}

}

Why This Works Perfectly:

¬∑ ‚úÖ Clear domain boundaries ‚Äî each type has distinct attributes

¬∑ ‚úÖ Different business logic ‚Äî shipping vs licensing

¬∑ ‚úÖ Self-contained ‚Äî no external dependencies

¬∑ ‚úÖ Easy to test ‚Äî simple validation rules

¬∑ ‚úÖ Extensible ‚Äî easy to add new product types

¬∑ ‚úÖ Real-world relevance ‚Äî matches actual e-commerce needs

---

üìã Implementation Example (Already Done)

Project Layout

src/

‚îî‚îÄ‚îÄ product/

‚îú‚îÄ‚îÄ Product.java # from Task 2‚Äì3 (with guards and constructors)

‚îú‚îÄ‚îÄ PhysicalProduct.java # Product subclass

‚îî‚îÄ‚îÄ DigitalProduct.java # Product subclass

1) PhysicalProduct extends Product

Private fields:

¬∑ double weightKg (0..1000)

¬∑ double lengthCm, widthCm, heightCm (each 0..1000)

Methods:

¬∑ boolean trySetWeightKg(double v)

¬∑ boolean trySetDimensions(double l, double w, double h) ‚Äî all valid, otherwise false

¬∑ double estimateShippingCost() Formula: volumetric = (l * w * h) / 5000.0 ‚Üí billable = max(weightKg, volumetric) ‚Üí cost = billable * 100 (KZT)

Constructors (chaining required):

¬∑ PhysicalProduct() ‚Äî safe defaults via super()

¬∑ PhysicalProduct(String id, String name, double price, double weightKg)

¬∑ PhysicalProduct(String id, String name, String description, double price, int quantity, double weightKg, double l, double w, double h)

Inside constructors use trySet... from Product; invalid values are ignored (defaults are preserved).

2) DigitalProduct extends Product

Private fields:

¬∑ double downloadSizeMb (0..1_000_000)

¬∑ String licenseKey (nullable, length ‚â§ 64)

Methods:

¬∑ boolean trySetDownloadSizeMb(double v)

¬∑ boolean trySetLicenseKey(String key)

¬∑ boolean isLicenseRequired() ‚Üí licenseKey != null && !licenseKey.isBlank()

Constructors:

¬∑ DigitalProduct()

¬∑ DigitalProduct(String id, String name, double price, double downloadSizeMb)

¬∑ DigitalProduct(String id, String name, String description, double price, int quantity, double downloadSizeMb, String licenseKey)

3) Printing

Override toString() in each subclass: add subclass info to super.toString().

---

üß™ Demo (product.ShopDemo4)

Show at minimum:

1. Creation using three types of constructors for each subclass (one example each).

2. Valid and invalid updates:

laptop.trySetDimensions(-1, 10, 10) // false

ebook.trySetDownloadSizeMb(2048) // true

3. Subclass method calls:

laptop.estimateShippingCost();

ebook.isLicenseRequired();

4. Printing via System.out.println(...) ‚Äî shows toString() of base class and subclass additions.

lab 5
Practice 5 ‚Äî Polymorphism: Price Policies + Method Overloading/Overriding

Builds on: Task 1‚Äì3 (Product with encapsulation/constructors/static), Task 4 (PhysicalProduct, DigitalProduct). Scope: Keep the project minimal: Products only (no Orders/Payments).


üéØ Goal

Demonstrate polymorphism with a unified price rules interface, plus overloading (compile-time polymorphism) and overriding (runtime polymorphism) on Product subclasses.

You will:

1. Introduce PricePolicy (an interface for pricing rules).

2. Implement three rules: PercentageOff, FixedOff, BogoHalf (buy-one-get-one-half).

3. Overload finalPrice(...) methods in Product.

4. Override price calculation in PhysicalProduct and DigitalProduct.

5. Use a polymorphic list (List<Product>, List<PricePolicy>) in a demo to show different behavior per subtype.


üìÅ Project Structure

src/

‚îî‚îÄ‚îÄ product/

‚îú‚îÄ‚îÄ Product.java

‚îú‚îÄ‚îÄ PhysicalProduct.java

‚îú‚îÄ‚îÄ DigitalProduct.java

‚îú‚îÄ‚îÄ pricing/

‚îÇ ‚îú‚îÄ‚îÄ PricePolicy.java

‚îÇ ‚îú‚îÄ‚îÄ PercentageOff.java

‚îÇ ‚îú‚îÄ‚îÄ FixedOff.java

‚îÇ ‚îî‚îÄ‚îÄ BogoHalf.java

‚îî‚îÄ‚îÄ ShopDemo5.java


1) Interface: PricePolicy

// product/pricing/PricePolicy.java

package product.pricing;


import product.Product;


public interface PricePolicy {

/** Human-readable rule name (for printing). */

String name();


/**

* Calculate the FINAL cost for 'qty' units of 'p' (NO shipping here).

* Must NOT mutate Product.

*/

double apply(Product p, int qty);


/** By default, applicable to all products. */

default boolean applicableTo(Product p) { return true; }

}

Implementations

// product/pricing/PercentageOff.java

package product.pricing;

import product.Product;


public class PercentageOff implements PricePolicy {

private final double percent; // 0..90


public PercentageOff(double percent) {

this.percent = Math.max(0, Math.min(90, percent));

}


@Override public String name() { return "Percent-" + percent + "%"; }


@Override public double apply(Product p, int qty) {

double unit = p.getPrice() * (1 - percent / 100.0);

return unit * Math.max(0, qty);

}

}

// product/pricing/FixedOff.java

package product.pricing;

import product.Product;


public class FixedOff implements PricePolicy {

private final double amount; // >= 0


public FixedOff(double amount) { this.amount = Math.max(0, amount); }


@Override public String name() { return "Fixed-" + amount; }


@Override public double apply(Product p, int qty) {

double unit = Math.max(0.0, p.getPrice() - amount);

return unit * Math.max(0, qty);

}

}

// product/pricing/BogoHalf.java

// For every pair: second item is -50%.

// Price for a pair = 1.5 * price; average = 0.75 * price per unit.

package product.pricing;

import product.Product;


public class BogoHalf implements PricePolicy {

@Override public String name() { return "BOGO-HALF"; }


@Override public double apply(Product p, int qty) {

double price = p.getPrice();

int pairs = Math.max(0, qty) / 2;

int singles = Math.max(0, qty) % 2;

return pairs * (price * 1.5) + singles * price;

}

}


2) Product: Method Overloading

Add overloads to Product (keep your existing fields/guards from previous tasks):

// Product.java ‚Äî add these overloads


// 1) Single unit, no rules

public double finalPrice() {

return getPrice();

}


// 2) qty units, no rules

public double finalPrice(int qty) {

if (qty <= 0) return 0.0;

return getPrice() * qty;

}


// 3) qty + single rule (no shipping here; subclasses may add it)

public double finalPrice(int qty, product.pricing.PricePolicy policy) {

if (qty <= 0) return 0.0;

if (policy == null || !policy.applicableTo(this)) return finalPrice(qty);

return policy.apply(this, qty);

}


// 4) qty + list of rules (choose the best = minimal price)

public double finalPrice(int qty, java.util.List<product.pricing.PricePolicy> policies) {

if (qty <= 0) return 0.0;

if (policies == null || policies.isEmpty()) return finalPrice(qty);

double best = Double.POSITIVE_INFINITY;

for (var pp : policies) {

double v = finalPrice(qty, pp);

if (v < best) best = v;

}

return best;

}


3) Subclasses: Method Overriding

PhysicalProduct

Add shipping once per order (after discounts). Reuse your estimateShippingCost() from Task 4.

// PhysicalProduct.java ‚Äî override single-rule version

@Override

public double finalPrice(int qty, product.pricing.PricePolicy policy) {

double base = super.finalPrice(qty, policy); // rule applied

return base + estimateShippingCost(); // add shipping once

}


// (optional) also override the List<PricePolicy> version to add shipping to the chosen best:

@Override

public double finalPrice(int qty, java.util.List<product.pricing.PricePolicy> policies) {

double base = super.finalPrice(qty, policies);

return base + estimateShippingCost();

}

DigitalProduct

Ignore BOGO-half (digital items don‚Äôt participate). Two options:

¬∑ (Simple) Handle in DigitalProduct.finalPrice(...).

¬∑ (Clean) Override applicableTo in BogoHalf to return false for DigitalProduct (optional).

Simple option:

// DigitalProduct.java

@Override

public double finalPrice(int qty, product.pricing.PricePolicy policy) {

if (policy instanceof product.pricing.BogoHalf) {

return super.finalPrice(qty); // ignore BOGO-half for digital

}

return super.finalPrice(qty, policy);

}


4) Demo ‚Äî ShopDemo5 (Polymorphic Lists)

// product/ShopDemo5.java

package product;


import product.pricing.*;

import java.util.List;


public class ShopDemo5 {

public static void main(String[] args) {

PhysicalProduct laptop = new PhysicalProduct("P-LAP-1","Laptop",450_000.0,1.8);

laptop.trySetDimensions(35,24,2);


DigitalProduct ebook = new DigitalProduct("P-EBK-1","E-Book",1_500.0,12.5);


List<Product> items = List.of(laptop, ebook);

List<PricePolicy> rules = List.of(new PercentageOff(10), new FixedOff(50), new BogoHalf());


for (Product p : items) {

for (int qty : new int[]{1, 2}) {

System.out.println("\n== " + p.getName() + " | qty=" + qty);

System.out.println("Base: " + p.finalPrice(qty));


for (PricePolicy r : rules) {

System.out.println(r.name() + ": " + p.finalPrice(qty, r));

}

System.out.println("Best(of all): " + p.finalPrice(qty, rules));

}

}

}

}

Expected observations

¬∑ PhysicalProduct adds shipping on top of any rule.

¬∑ DigitalProduct ignores BogoHalf but accepts other rules.

¬∑ Overloading chooses method by signature; overriding resolves by runtime type.

lab 6
Abstract Classes & Interfaces: Promotions (Template Method) + Tax & Shipping Interfaces

Builds on: Task 1‚Äì5 (Product, PhysicalProduct, DigitalProduct, price rules). Scope: Keep the domain minimal (Products only). We will add one abstract class for promotions and two small interfaces for cross-cutting behavior.

1. Refactor pricing rules to showcase an abstract class with a Template Method.

2. Add interfaces for tax and shipping that different product types can implement/use.

You will:

¬∑ Create abstract class Promotion that implements PricePolicy and factors shared logic.

¬∑ Implement three concrete promotions by extending Promotion.

¬∑ Add interfaces TaxPolicy and Shippable and wire them into price calculation.

¬∑ Demonstrate polymorphism with lists of Promotion and different TaxPolicy on PhysicalProduct vs DigitalProduct.

üìÅ Project Structure

src/

‚îî‚îÄ‚îÄ product/

‚îú‚îÄ‚îÄ Product.java

‚îú‚îÄ‚îÄ PhysicalProduct.java

‚îú‚îÄ‚îÄ DigitalProduct.java

‚îú‚îÄ‚îÄ pricing/

‚îÇ ‚îú‚îÄ‚îÄ PricePolicy.java # from Task 5 (keep it)

‚îÇ ‚îú‚îÄ‚îÄ Promotion.java # NEW (abstract class)

‚îÇ ‚îú‚îÄ‚îÄ PercentagePromotion.java # extends Promotion

‚îÇ ‚îú‚îÄ‚îÄ FixedPromotion.java # extends Promotion

‚îÇ ‚îî‚îÄ‚îÄ BogoHalfPromotion.java # extends Promotion (pair logic)

‚îú‚îÄ‚îÄ tax/

‚îÇ ‚îú‚îÄ‚îÄ TaxPolicy.java # NEW (interface)

‚îÇ ‚îú‚îÄ‚îÄ NoTax.java # implements TaxPolicy

‚îÇ ‚îú‚îÄ‚îÄ FlatVat.java # implements TaxPolicy (e.g., 12%)

‚îÇ ‚îî‚îÄ‚îÄ ReducedDigitalVat.java # implements TaxPolicy (e.g., 5% only for DigitalProduct)

‚îú‚îÄ‚îÄ shipping/

‚îÇ ‚îî‚îÄ‚îÄ Shippable.java # NEW (interface)

‚îî‚îÄ‚îÄ ShopDemo6.java

lab 7
–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ: –ê–Ω–∞–ª–∏–∑ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ —Å–æ–≥–ª–∞—Å–Ω–æ –ø—Ä–∏–Ω—Ü–∏–ø–∞–º SOLID (SRP –∏ OCP)

–¢–µ–º–∞:

–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ Single Responsibility –∏ Open/Closed –≤ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –º–æ–¥—É–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã —Ü–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è (Promotions, Tax Policies, Shipping).


–¶–µ–ª—å:

–ù–∞ –ø—Ä–∏–º–µ—Ä–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ Java-–ø—Ä–æ–µ–∫—Ç–∞ –∏–∑—É—á–∏—Ç—å, –∫–∞–∫ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å –¥–≤–∞ –±–∞–∑–æ–≤—ã—Ö –ø—Ä–∏–Ω—Ü–∏–ø–∞ SOLID:

¬∑ S ‚Äî Single Responsibility Principle (SRP)

¬∑ O ‚Äî Open/Closed Principle (OCP)

–ê —Ç–∞–∫–∂–µ –∑–∞–∫—Ä–µ–ø–∏—Ç—å –Ω–∞–≤—ã–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏, –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π (Strategy), —à–∞–±–ª–æ–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ (Template Method), –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤ –∏ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è.


üìÅ –ò—Å—Ö–æ–¥–Ω—ã–π –ø—Ä–æ–µ–∫—Ç

–°—Ç—É–¥–µ–Ω—Ç—É –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è Java-–ø—Ä–æ–µ–∫—Ç —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:

src/

‚îî‚îÄ‚îÄ product/

‚îú‚îÄ‚îÄ Product.java

‚îú‚îÄ‚îÄ PhysicalProduct.java

‚îú‚îÄ‚îÄ DigitalProduct.java

‚îú‚îÄ‚îÄ pricing/

‚îÇ ‚îú‚îÄ‚îÄ PricePolicy.java

‚îÇ ‚îú‚îÄ‚îÄ Promotion.java

‚îÇ ‚îú‚îÄ‚îÄ PercentagePromotion.java

‚îÇ ‚îú‚îÄ‚îÄ FixedPromotion.java

‚îÇ ‚îî‚îÄ‚îÄ BogoHalfPromotion.java

‚îú‚îÄ‚îÄ tax/

‚îÇ ‚îú‚îÄ‚îÄ TaxPolicy.java

‚îÇ ‚îú‚îÄ‚îÄ NoTax.java

‚îÇ ‚îú‚îÄ‚îÄ FlatVat.java

‚îÇ ‚îî‚îÄ‚îÄ ReducedDigitalVat.java

‚îú‚îÄ‚îÄ shipping/

‚îÇ ‚îî‚îÄ‚îÄ Shippable.java

‚îî‚îÄ‚îÄ ShopDemo6.java


–ó–∞–¥–∞–Ω–∏–µ (—Ç–µ–æ—Ä–µ—Ç–∏–∫–æ-–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ)

–ß–∞—Å—Ç—å 1 ‚Äî –ê–Ω–∞–ª–∏–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è SRP –∏ OCP (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è)

1.1. –ê–Ω–∞–ª–∏–∑ SRP

–î–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –∫–ª–∞—Å—Å–æ–≤:

¬∑ Product

¬∑ PhysicalProduct

¬∑ DigitalProduct

¬∑ Promotion

¬∑ PercentagePromotion

¬∑ FixedPromotion

¬∑ BogoHalfPromotion

¬∑ TaxPolicy

¬∑ FlatVat

¬∑ ReducedDigitalVat

¬∑ Shippable

–í—ã–ø–æ–ª–Ω–∏—Ç—å:

1. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ–¥–Ω—É —á—ë—Ç–∫–æ –≤—ã—Ä–∞–∂–µ–Ω–Ω—É—é –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å (1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è).

2. –£–∫–∞–∑–∞—Ç—å, –∫–∞–∫–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –ø—Ä–∏–≤–µ–¥—É—Ç –∫ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏–∑–º–µ–Ω–∏—Ç—å —ç—Ç–æ—Ç –∫–ª–∞—Å—Å.

3. –°–¥–µ–ª–∞—Ç—å –≤—ã–≤–æ–¥: —Å–æ–±–ª—é–¥—ë–Ω SRP –∏–ª–∏ –Ω–∞—Ä—É—à–µ–Ω? –ü–æ—á–µ–º—É?


1.2. –ê–Ω–∞–ª–∞–ª–∏–∑ OCP

–î–ª—è —Ç–µ—Ö –∂–µ –∫–ª–∞—Å—Å–æ–≤:

1. –û–±—ä—è—Å–Ω–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —ç—Ç–æ—Ç –∫–ª–∞—Å—Å (–¥–æ–±–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å) –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –µ–≥–æ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞.

2. –ï—Å–ª–∏ –∫–ª–∞—Å—Å –Ω–∞—Ä—É—à–∞–µ—Ç OCP, –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Å–ø–æ—Å–æ–± –µ–≥–æ –ø–µ—Ä–µ–ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–∫—Ä–∞—Ç–∫–æ, –±–µ–∑ –∫–æ–¥–∞).


–ß–∞—Å—Ç—å 2 ‚Äî –ü—Ä–∞–∫—Ç–∏–∫–∞ –ø–æ OCP: —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–ª–∞—Å—Å–æ–≤

–ó–∞–¥–∞–Ω–∏–µ 2.1.

–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —Ç–∏–ø –∞–∫—Ü–∏–∏: Buy 3 ‚Äî Pay for 2 (–∫–∞–∂–¥–∞—è —Ç—Ä–µ—Ç—å—è –µ–¥–∏–Ω–∏—Ü–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞)

–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ:

¬∑ –Ω–µ–ª—å–∑—è –∏–∑–º–µ–Ω—è—Ç—å –Ω–∏ –æ–¥–∏–Ω –∏–∑ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–ª–∞—Å—Å–æ–≤ (Promotion, Product, PricePolicy –∏ —Ç.–¥.)

¬∑ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —Ç–æ–ª—å–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ —Ñ–∞–π–ª—ã –∏ –º–µ–Ω—è—Ç—å ShopDemo6.


–ó–∞–¥–∞–Ω–∏–µ 2.2.

–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –Ω–∞–ª–æ–≥–æ–≤—É—é –ø–æ–ª–∏—Ç–∏–∫—É: ProgressiveVat

–ü—Ä–∞–≤–∏–ª–∞:

¬∑ –î–æ 100 ‚Üí +5%

¬∑ 100‚Äì500 ‚Üí +10%

¬∑ –°–≤—ã—à–µ 500 ‚Üí +15%

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:

¬∑ –ù–µ –º–µ–Ω—è—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–ª–∞—Å—Å—ã (OCP).

¬∑ –¢–æ–ª—å–∫–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª –∏ –æ–±–Ω–æ–≤–∏—Ç—å ShopDemo6.


–ó–∞–¥–∞–Ω–∏–µ 2.3.

–ü–µ—Ä–µ–ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∞–≤–∫–∏ –¥–ª—è —Å—Ç—Ä–æ–≥–æ–≥–æ —Å–æ–±–ª—é–¥–µ–Ω–∏—è OCP:

1. –°–æ–∑–¥–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å:

2. ShippingPolicy

3. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –ø–æ–ª–∏—Ç–∏–∫–∏:

o SimpleWeightShippingPolicy

o FreeOverThresholdShippingPolicy

o ExpressShippingPolicy

4. –ò–∑–º–µ–Ω–∏—Ç—å PhysicalProduct, —á—Ç–æ–±—ã:

o –æ–Ω –Ω–µ —Ö—Ä–∞–Ω–∏–ª –ª–æ–≥–∏–∫—É –¥–æ—Å—Ç–∞–≤–∫–∏ –≤–Ω—É—Ç—Ä–∏ —Å–µ–±—è

o –ø—Ä–∏–Ω–∏–º–∞–ª ShippingPolicy —á–µ—Ä–µ–∑ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä

o –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–ª —Ä–∞—Å—á—ë—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ—Å—Ç–∞–≤–∫–∏ —ç—Ç–æ–π –ø–æ–ª–∏—Ç–∏–∫–µ

5. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ —Ç–µ–ø–µ—Ä—å –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–π –¥–æ—Å—Ç–∞–≤–∫–∏ –º–æ–∂–Ω–æ –æ–±—Ö–æ–¥–∏—Ç—å—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è PhysicalProduct

